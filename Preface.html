<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title></title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Preface</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">前書き</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">ようこそ</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
この電子文章は「ソフトウェアの基礎（プログラミングとプログラミング言語の数学的理論）」という、大学後半〜院生向けの1学期分の講義のために書かれたものです。この講義では、Coq上で関数プログラミング、論理学、操作的意味論、Hoare論理、静的型システムの基礎を学ぶことができます。論理学やプログラミング言語に関する特定の予備知識は必要ありませんが、ある程度数学に通じていると理解の助けとなるでしょう。

<div class="paragraph"> </div>

このコースの重要な特徴は、教材のテキストがCoqのスクリプトファイルそのものとなっており、学習の進み具合を「形式的」かつ「機械的」に確認しながら学んでいくことができる、ということです。このコースでは、Coqの対話モードを使って、ソースを1行1行追いながら動きを理解していきます。講義のほとんどはCoqで組み立てられ、Coq上で作業し演習するようデザインされています。

<div class="paragraph"> </div>

このファイルは章立てされ整理されており、1学期ぶんの教材として十分で、順番に学習していけるよう、筋道立てて作成されています。さらに加えて、いくつかのトピックについて追加項目があります。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">概要</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
信頼できるソフトウェアの構築は困難です。意図通りに動作するソフトウェアの構築は難しいものですが、現代のソフトウェアシステムのスケールと複雑さ、その構築に関わる人数、それに課せられる要求の幅広さ、によりさらに困難さは極まっています。同時に、私たちの社会のあらゆる側面にソフトウェアが組み込まれてきて、バグとセキュリティのコストは増大しています。

<div class="paragraph"> </div>

コンピュータサイエンスとソフトウェア工学は、この問題に対応するためにソフトウェアの信頼性を向上させる数多くの技法を開発してきました。その範囲は、ソフトウェアプロジェクトの管理と開発チームの構成（例：エクストリームプログラミング）、ライブラリの設計哲学（例：MVC、publish-subscribeなど）、プログラミング言語（例：オブジェクト指向プログラミング、アスペクト指向プログラミング、関数型プログラミング）から、ソフトウェアの性質の仕様化と論証のための数学的技法とそれらの性質の検証を支援するツールまで多岐にわたります。

<div class="paragraph"> </div>

このコースはこの最後に挙げた技法に焦点をあてています。このテキストは次の5つの概念を綴り合わせたものです。

<div class="paragraph"> </div>

  (1) プログラムの要求を記述し正当性を確認するための_論理学_の基本的ツール

<div class="paragraph"> </div>

  (2) 厳格な論理的推論を構築するための_証明支援系_の利用

<div class="paragraph"> </div>

  (3) プログラミングの道具として、またプログラミングと論理の架け橋としての、_関数型プログラミング_の考え方

<div class="paragraph"> </div>

  (4) _特定のプログラムの性質を推論する_形式的技法（例えば、いかなる入力でもループが停止するか、整列を行うプログラムが実際にその仕様を満たすか）

<div class="paragraph"> </div>

  (5) 与えられたプログラミング言語の_あらゆる_プログラムのよい振る舞いを保証するための_型システム_の利用（例えば、型の正しいJavaプログラムは実行時に異常終了しないという事実）

<div class="paragraph"> </div>

これらの話題のそれぞれはそれ自身で1つのコースになる「濃い」ものです。それらを全てとりあげるということはつまり、言及できない事柄も多く残されるということです。But we hope readers will agree that the
    themes illuminate and amplify each other in useful ways, and that
    bringing them together creates a foundation from which it will be
    easy to dig into any of them more deeply.  Some suggestions for
    supplemental texts can be found in the <span class="inlinecode"><span class="id" type="var">Postscript</span></span> chapter. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h2 class="section">論理学</h2>

<div class="paragraph"> </div>

 Logic is the field of study whose subject matter is <i>proofs</i> --
    unassailable arguments for the truth of particular propositions.

<div class="paragraph"> </div>

    Volumes have been written about the central role of logic in
    computer science.  Manna and Waldinger called it "the calculus of
    computer science," while Halpern et al.'s paper <i>On the Unusual
    Effectiveness of Logic in Computer Science</i> catalogs scores of
    ways in which logic offers critical tools and insights.  

<div class="paragraph"> </div>

   In particular, the fundamental notion of inductive proofs is
   ubiquitous in all of computer science.  You have surely seen them
   before, in contexts from discrete math to analysis of algorithms,
   but in this course we will examine them much more deeply than you
   have probably done so far. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h2 class="section">証明支援系</h2>

<div class="paragraph"> </div>

 The flow of ideas between logic and computer science has not gone
    only one way: CS has made its own contributions to logic.  One of
    these has been the development of tools for constructing proofs of
    logical propositions.  These tools fall into two broad categories:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Automated theorem provers</i> provide "push-button" operation:
         you give them a proposition and they return either <i>true</i>,
         <i>false</i>, or <i>ran out of time</i>.  Although their capabilities
         are limited to fairly specific sorts of reasoning, they have
         matured enough to be useful now in a huge variety of
         settings.  Examples of such tools include SAT solvers, SMT
         solvers, and model checkers.

<div class="paragraph"> </div>


</li>
<li> <i>Proof assistants</i> are hybrid tools that try to automate the
         more routine aspects of building proofs while depending on
         human guidance for more difficult aspects.  Widely used proof
         assistants include Isabelle, Agda, Twelf, ACL2, PVS, and Coq,
         among many others.

</li>
</ul>

<div class="paragraph"> </div>

    This course is based around Coq, a proof assistant that has been
    under development since 1983 at a number of French research labs
    and universities.  Coq provides a rich environment for interactive
    development of machine-checked formal reasoning.  The kernel of
    the Coq system is a simple proof-checker which guarantees that
    only correct deduction steps are performed.  On top of this
    kernel, the Coq environment provides high-level facilities for
    proof development, including powerful tactics for constructing
    complex proofs semi-automatically, and a large library of common
    definitions and lemmas.

<div class="paragraph"> </div>

    Coq has been a critical enabler for a huge variety of work across
    computer science and mathematics.  

<div class="paragraph"> </div>

<ul class="doclist">
<li> As a platform for the modeling of programming languages, it has
      become a standard tool for researchers who need to describe and
      reason about complex language definitions.  It has been used,
      for example, to check the security of the JavaCard platform,
      obtaining the highest level of common criteria certification,
      and for formal specifications of the x86 and LLVM instruction
      sets.

<div class="paragraph"> </div>


</li>
<li> As an environment for the development of formally certified
      programs, Coq has been used to build CompCert, a fully-verified
      optimizing compiler for C, for proving the correctness of subtle
      algorithms involving floating point numbers, and as the basis
      for Certicrypt, an environment for reasoning about the security
      of cryptographic algorithms.

<div class="paragraph"> </div>


</li>
<li> As a realistic environment for experiments with programming with
      dependent types, it has inspired numerous innovations.  For
      example, the Ynot project at Harvard embeds "relational Hoare
      reasoning" (an extension of the <i>Hoare Logic</i> we will see later
      in this course) in Coq.

<div class="paragraph"> </div>


</li>
<li> As a proof assistant for higher-order logic, it has been used to
      validate a number of important results in mathematics.  For
      example, its ability to include complex computations inside
      proofs made it possible to develop the first formally verified
      proof of the 4-color theorem.  This proof had previously been
      controversial among mathematicians because part of it included
      checking a large number of configurations using a program. In
      the Coq formalization, everything is checked, including the
      correctness of the computational part.  More recently, an even
      more massive effort led to a Coq formalization of the
      Feit-Thompson Theorem -- the first major step in the
      classification of finite simple groups. 

</li>
</ul>

<div class="paragraph"> </div>

   By the way, in case you're wondering about the name, here's what
   the official Coq web site says: "Some French computer scientists
   have a tradition of naming their software as animal species: Caml,
   Elan, Foc or Phox are examples of this tacit convention. In French,
   “coq” means rooster, and it sounds like the initials of the
   Calculus of Constructions CoC on which it is based."  The rooster
   is also the national symbol of France, and "Coq" are the first
   three letters of the name of Thierry Coquand, one of Coq's early
   developers. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h2 class="section">関数型プログラミング</h2>

<div class="paragraph"> </div>

 The term <i>functional programming</i> refers both to a collection of
    programming idioms that can be used in almost any programming
    language and to a particular family of programming languages that are
    designed to emphasize these idioms, including Haskell, OCaml,
    Standard ML, F#, Scala, Scheme, Racket, Common Lisp, Clojure,
    Erlang, and Coq.  

<div class="paragraph"> </div>

    Functional programming has been developed by researchers over many
    decades -- indeed, its roots go back to Church's lambda-calculus,
    developed in the 1930s before the era of the computer began!  But
    in the past two decades it has enjoyed a surge of interest among
    industrial engineers and language designers, playing a key role in
    high-value systems at companies like Jane St. Capital, Microsoft,
    Facebook, and Ericsson.

<div class="paragraph"> </div>

    The most basic tenet of functional programming is that, as much as
    possible, computation should be <i>pure</i>: the only effect of running
    a computation should be to produce a result; the computation
    should be free from <i>side effects</i> such as I/O, assignments to
    mutable variables, or redirecting pointers.  For example, whereas
    an <i>imperative</i> sorting function might take a list of numbers and
    rearrange the pointers to put the list in order, a pure sorting
    function would take the original list and return a <i>new</i> list
    containing the same numbers in sorted order.

<div class="paragraph"> </div>

    One significant benefit of this style of programming is that it
    makes programs easier to understand and reason about.  If every
    operation on a data structure yields a new data structure, leaving
    the old one intact, then there is no need to worry about where
    else in the program the structure is being shared, whether a
    change by one part of the program might break an invariant that
    another part of the program thinks is being enforced.  These
    considerations are particularly critical in concurrent programs,
    where any mutable state that is shared between threads is a
    potential source of pernicious bugs.  Indeed, a large part of the
    recent interest in functional programming in industry is due to its
    simple behavior in the presence of concurrency.

<div class="paragraph"> </div>

    Another reason for the current excitement about functional
    programming is related to this one: functional programs are often
    much easier to parallelize than their imperative counterparts.  If
    running a computation has no effect other than producing a result,
    then it can be run anywhere.  If a data structure is never
    modified in place, it can be copied freely, across cores or across
    the network.  Indeed, the MapReduce idiom that lies at the heart
    of massively distributed query processors like Hadoop and is used
    at Google to index the entire web is an instance of functional
    programming.

<div class="paragraph"> </div>

    For purposes of this course, functional programming has one other
    significant attraction: it serves as a bridge between logic and
    computer science.  Indeed, Coq itself can be seen as a combination
    of a small but extremely expressive functional programming
    language, together with a set of tools for stating and proving
    logical assertions.  However, when we come to look more closely,
    we will find that these two sides of Coq are actually aspects of
    the very same underlying machinery -- i.e., <i>proofs are programs</i>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h2 class="section">プログラムの検証</h2>

<div class="paragraph"> </div>

 The first third of the book is devoted to developing the
    conceptual framework of logic and functional programming and to
    gaining enough fluency with the essentials of Coq to use it for
    modeling and reasoning about nontrivial artifacts.  From this
    point on, we will increasingly turn our attention to two broad
    topics of critical importance to the enterprise of building
    reliable software (and hardware!): techniques for proving specific
    properties of particular <i>programs</i> and for proving general
    properties of whole programming <i>languages</i>.  

<div class="paragraph"> </div>

    For both of these, the first thing we need is a way of
    representing programs as mathematical objects (so we can talk
    about them precisely) and of describing their behavior in terms of
    mathematical functions or relations.  Our tools for these tasks
    will be <i>abstract syntax</i> and <i>operational semantics</i>, a method of
    specifying the behavior of programs by writing abstract
    interpreters.  At the beginning, we will work with operational
    semantics in the so-called "big-step" style, which leads to
    somewhat simpler and more readable definitions, in those cases
    where it is applicable.  Later on, we will switch to a more
    detailed "small-step" style, which helps make some useful
    distinctions between different sorts of "nonterminating" program
    behaviors and which can be applied to a broader range of language
    features, including concurrency.

<div class="paragraph"> </div>

    The first programming language we consider in detail is Imp, a
    tiny toy language capturing the most fundamental features of
    conventional imperative languages: variables, assignment,
    conditionals, and loops. We study two different ways of reasoning
    about the properties of Imp programs.  

<div class="paragraph"> </div>

    First, we consider what it means to say that two Imp programs are
    <i>equivalent</i> in the sense that they give the same behaviors for
    all initial memories.  This notion of equivalence then becomes a
    criterion for judging the correctness of <i>metaprograms</i> --
    programs that manipulate other programs, such as compilers and
    optimizers.  We build a simple optimizer for Imp and prove that it
    is correct.

<div class="paragraph"> </div>

    Second, we develop a methodology for proving that Imp programs
    satisfy some formal specification of their behavior.  We introduce
    the notion of <i>Hoare triples</i> -- Imp programs annotated with pre-
    and post-conditions describing what should be true about the
    memory in which they are started and what they promise to make
    true about the memory in which they terminate -- and the reasoning
    principles of <i>Hoare Logic</i>, a "domain-specific logic" specialized
    for convenient compositional reasoning about imperative programs,
    with concepts like "loop invariant" built in.

<div class="paragraph"> </div>

    This part of the course will give you a taste of the key ideas and
    mathematical tools used for a wide variety of real-world software
    and hardware verification tasks.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h2 class="section">型システム</h2>

<div class="paragraph"> </div>

 Our final major topic, covering the last third of the course, is
    <i>type systems</i>, a powerful set of tools for establishing
    properties of <i>all</i> programs in a given language.

<div class="paragraph"> </div>

    Type systems are the best established and most popular example of
    a highly successful class of formal verification techniques known
    as <i>lightweight formal methods</i>.  These are reasoning techniques
    of modest power -- modest enough that automatic checkers can be
    built into compilers, linkers, or program analyzers and thus be
    applied even by programmers unfamiliar with the underlying
    theories.  (Other examples of lightweight formal methods include
    hardware and software model checkers and run-time property
    monitoring, a collection of techniques that allow a system to
    detect, dynamically, when one of its components is not behaving
    according to specification).

<div class="paragraph"> </div>

    In a sense, this topic brings us full circle: the language whose
    properties we study in this part, called the <i>simply typed
    lambda-calculus</i>, is essentially a simplified model of the core of
    Coq itself!

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab9"></a><h1 class="section">実用性</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h2 class="section">学習に必要なもの</h2>

<div class="paragraph"> </div>

 Coq runs on Windows, Linux, and OS X.  You will need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A current installation of Coq, available from the Coq home
         page.  Everything should work with version 8.4.

<div class="paragraph"> </div>


</li>
<li> An IDE for interacting with Coq.  Currently, there are two
         choices:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Proof General is an Emacs-based IDE.  It tends to be
             preferred by users who are already comfortable with
             Emacs.  It requires a separate installation (google
             "Proof General").

<div class="paragraph"> </div>


</li>
<li> CoqIDE is a simpler stand-alone IDE.  It is distributed
             with Coq, but on some platforms compiling it involves
             installing additional packages for GUI libraries and
             such. 
</li>
</ul>

</li>
</ul>
 Coqは、Windowsと多くのUNIX系OS（LinuxやMacOS Xを含む）で動きます。具体的には

<div class="paragraph"> </div>

<ul class="doclist">
<li> Coqホームページにある最新版のCoq。（全てのサンプルソースはバージョン8.4でコンパイルできることが確認されています）

</li>
<li> Coqを対話的に操作するIDE。現在、以下の二つから選択できます。
<ul class="doclist">
<li> ProofGeneralは、Emacs上に作られたIDEです。すでにEmacsに慣れている人向けのものです。Coqとは別にインストールする必要があります。（詳しくはgoogleで"ProofGeneral"を検索してください）

</li>
<li> CoqIDEは、スタンドアロンで動作するシンプルなIDEです。Coqと一緒に配布されています。しかしいくつかのプラットホームではGUIライブラリなどの追加パッケージをインストールする必要があります。 
</li>
</ul>

</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h2 class="section">練習問題について</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
各章には、たくさんの練習問題がついています。練習問題についている星印の数には、以下のような意味があります。

<div class="paragraph"> </div>

<ul class="doclist">
<li> ★　テキストのポイントを強調する簡単な問題で、たいていの読者は1〜2分でできる。遭遇したら取り組むことを習慣にしましょう。

<div class="paragraph"> </div>


<div class="paragraph"> </div>


</li>
<li> ★★　素直で簡単な問題（5〜10分でできるでしょう）

<div class="paragraph"> </div>


</li>
<li> ★★★　少し考えないといけない問題（15〜30分ほどかかるでしょう）

<div class="paragraph"> </div>


</li>
<li> ★★★★　さらに難しい問題（1〜2時間）

</li>
</ul>

<div class="paragraph"> </div>

「発展(advanced)」「任意(optional)」と記されている問題があります。
章の主要な題材はいずれの印もない問題だけで充分カバーできます。
"発展"問題はさらに挑戦したい（そしてその見返りとしての題材の深い理解を得たい）読者のためのものです。"任意"問題は主な概念に関する少し追加の練習を提供し、読者によっては興味をもつ副次的な話題を紹介しています。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h2 class="section">章間の依存関係</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
章と章の間の依存関係と推奨する学習順序をまとめた図を<span class="inlinecode"><span class="id" type="var">deps_J.html</span></span>にまとめてあります。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h2 class="section">本教材Coqファイルの入手方法</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
この教材のリリース版のソース（CoqスクリプトとHTMLファイル）をtarで固めたものが、以下のURLで取得できます。
<pre>
        http://www.cis.upenn.edu/~bcpierce/sf
</pre>
    この資料を講義で利用している場合は、リリース版ではなくローカルに展開された版にアクセスする権限が与えられているかもしれません。

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab14"></a><h1 class="section">教育関係者へ</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
この資料を自分の講義で使おうと思った場合、ほぼまちがいなくあなたは書き直したり、追加したりしたいところが出てくるでしょう。そういった貢献は大歓迎です。

<div class="paragraph"> </div>

ぜひBenjamin Pierceまでemailをください。subversionのリポジトリと開発者メーリングリストにアカウントを用意します。リポジトリにはREADMEファイルがありますので、次にどうすべきかはそれを参照してください。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h1 class="section">Translations</h1>

<div class="paragraph"> </div>

 Thanks to the efforts of a team of volunteer translators, <i>Software 
    Foundations</i> can now be enjoyed in Japanese:

<div class="paragraph"> </div>

<ul class="doclist">
<li> http://proofcafe.org/sf

</li>
</ul>

</div>
<div class="code">

<br/>

<br/>
</div>
<table>
<tr>
<td>Global Index</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td><a href="index.html#global_P">P</a></td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>_</td>
<td>other</td>
<td>(1 entry)</td>
</tr>
<tr>
<td>Library Index</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td><a href="index.html#library_P">P</a></td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>_</td>
<td>other</td>
<td>(1 entry)</td>
</tr>
</table>
<hr/>
<h1>Global Index</h1>
<a name="global_P"></a><h2>P </h2>
<a href="Preface.html">Preface</a> [library]<br/>
<br/><br/><hr/>
<h1>Library Index</h1>
<a name="library_P"></a><h2>P </h2>
<a href="Preface.html">Preface</a> <br/>
<br/><br/><hr/><table>
<tr>
<td>Global Index</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td><a href="index.html#global_P">P</a></td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>_</td>
<td>other</td>
<td>(1 entry)</td>
</tr>
<tr>
<td>Library Index</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
<td>L</td>
<td>M</td>
<td>N</td>
<td>O</td>
<td><a href="index.html#library_P">P</a></td>
<td>Q</td>
<td>R</td>
<td>S</td>
<td>T</td>
<td>U</td>
<td>V</td>
<td>W</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
<td>_</td>
<td>other</td>
<td>(1 entry)</td>
</tr>
</table>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>